package myanswers;

import org.junit.Test;

import java.util.*;

/**
 * Created by smridul on 3/9/19.
 */
public class MalwareSpread {


    @Test
    public void test() {

       /* int graph[][] = new int[][]{
                {1, 1, 1},
                {1, 1, 1},
                {1, 1, 1},
        };

        int[] initial = new int[]{1, 2};

*/
        int graph[][] = new int[][]{{1, 1, 0},
                {1, 1, 0},
                {0, 0, 1},
        };
        int[] initial = new int[]{0, 1};


       /* int graph[][]  = new int[][]{
                {1, 0, 0, 0},
                {0, 1, 0, 0},
                {0, 0, 1, 1},
                {0, 0, 1, 1}
        };

        int[] initial = new int[]{3, 1};*/
        System.out.println(minMalwareSpread(graph, initial));
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        // start with 1
        int color = 1;
        int[] colors = new int[graph.length];

        Set<Integer> set = new HashSet<>();
        for (int i : initial) {
            set.add(i);
        }
        int max = Integer.MIN_VALUE;
        int index =0 ;
        int numberOfNodes = 0 ;
        for (int node : initial) {
            if(colors[node]!=0){
                numberOfNodes = 0;
            }else {
                numberOfNodes = bfs(node, color, colors, graph, set);
            }
            if (numberOfNodes > max) {
                max = numberOfNodes;
                index = node;
            }else if(numberOfNodes == max){
                index = Math.min(node, index);

            }
            color++;
        }

        return index;

    }


    public int bfs(int source, int color, int[] colors, int[][] graph, Set<Integer> set) {

        Queue<Integer> queue = new ArrayDeque<>();
        queue.add(source);
        int numberOfnodes = 0;
        colors[source] = color;
        boolean noEffect = false;
        while (!queue.isEmpty()) {
            int currentNode = queue.poll();
            for (int neighbour = 0; neighbour< graph.length; neighbour++) {
                if (graph[currentNode][neighbour]==1 && colors[neighbour] == 0 && neighbour != currentNode) {
                    if (set.contains(neighbour)) {
                        noEffect = true;
                    }
                    numberOfnodes++;
                    queue.add(neighbour);
                    colors[neighbour] = color;
                }
            }
        }
        return noEffect ? 0: numberOfnodes + 1;
    }

}
